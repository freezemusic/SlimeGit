/******************************************
 * .tmx generated by Tiled Map Editor 0.12.3 (www.mapeditor.org)
 * .plist generated by Texture Packer 3.9.1 (CodeAndWeb GmbH)
 ******************************************/

#include "Level.h"
#include "LevelObject.h"
#include "Player.h"
#include "../Panel/GamePanel.h"
#include "CCSoftFollow.h"

USING_NS_CC;

Level::Level(){
	this->schedule(schedule_selector(Level::update));
}

Scene* Level::createScene(){
	auto scene = Scene::createWithPhysics();

	auto panel = GamePanel::createLayer();
	scene->addChild(panel, 1, panelTag); //SCENE { panel }

	auto level = Level::create();
	scene->addChild(level, 0, levelTag); //SCENE { level }

	return scene;
}
Scene* Level::createSceneWithMap(std::string mapPath){
	auto scene = Level::createScene();
	auto level = (Level*)(scene->getChildByTag(levelTag));
	level->createLevel(mapPath);
	return scene;
}

//LEVEL SETUP
void Level::createLevel(std::string mapPath){
	//PHYSICS WORLD SETUP
	world = getScene()->getPhysicsWorld();
	world->setGravity(Vec2(0.0f, -980.0f));
	world->setDebugDrawMask(PhysicsWorld::DEBUGDRAW_ALL);
	//PARALLAX-MAP SETUP
	auto parallax = createParallax(mapPath);
	addChild(parallax); //SCENE { level { parallax { map } }
	//TILED MAP PARSING
	prepareLayers();
	addObjects(); //SCENE { level {  parallax { player } } }
}
//PARALLAX SETUP
ParallaxNode* Level::createParallax(std::string mapPath){
	auto parallax = ParallaxNode::create();
	parallax->setName("Parallax");
	parallax->setAnchorPoint(Vec2(0.5f, 0.5f));
	//SKY(-2)
	auto sky = CCSprite::create("bg.png");
	sky->setScale(0.7f);
	sky->setAnchorPoint(Vec2(0, 0));
	parallax->addChild(sky, -2, Vec2(0.1f, 0.1f), Vec2::ZERO);
	//MAP(0)
	map = TMXTiledMap::create(mapPath);
	map->setName("Map");
	for (const auto& child : map->getChildren()){
		static_cast<SpriteBatchNode*>(child)->getTexture()->setAntiAliasTexParameters();
	}
	parallax->addChild(map, 0, Vec2::ONE, Vec2::ZERO);

	return parallax;
}

//PARSE ALL FIXTURES
void Level::prepareLayers(){
	for (auto& object : map->getChildren()){
		//TO TILE LAYER
		auto layer = dynamic_cast<TMXLayer*>(object);
		if (layer != nullptr)
			this->createFixtures(layer);
	}
}
void Level::createFixtures(TMXLayer* layer){
	auto layerSize = layer->getLayerSize();
	//FOR EACH TILE
	for (int y = 0; y < layerSize.height; y++){
		for (int x = 0; x < layerSize.width; x++){
			//GET SPRITE
			auto tileSprite = layer->getTileAt(Vec2(x, y)); //AUTO-addSprite
			if (tileSprite)
				this->createRectFixture(layer, tileSprite);
		}
	}
}
void Level::createRectFixture(TMXLayer* layer, Sprite* spr){
	//TILE SIZE CALCULATION
	auto tileSize = map->getTileSize();
	const float ppm = 32.0f; //pixel per meter

	//PHYSICS BODY
	auto body = PhysicsBody::createBox(Size(tileSize.width, tileSize.width));
	body->setDynamic(false);
	body->setMass(PHYSICS_INFINITY);
	body->setContactTestBitmask(0xFFFFFFFF);
	spr->setPhysicsBody(body);
}

//PARSE ALL OBJECTS
void Level::addObjects(){
	auto objGroups = map->getObjectGroups();
	for (auto& objGroup : objGroups){
		auto objs = objGroup->getObjects();
		for (auto& obj : objs){
			auto prop = obj.asValueMap();
			auto type = prop.at("type");
			if (!type.isNull()){
				//TO LEVEL OBJECT
				this->addObject(type.asString().c_str(), prop);
				this->objectCount++;
			}
		}
	}
}
void Level::addObject(std::string className, ValueMap& prop){
	LevelObject* obj = nullptr;
	if (className == "Player"){
		obj = new Player;
		setGamePanelOnPlayer((Player*)obj);
	}
	//else if (className == "Monster")
	//	obj = new Monster;

	if (obj != nullptr){
		obj->setProperties(prop);
		obj->addSpriteToLevel(this);
		obj->addBody();
	}
}
void Level::setGamePanelOnPlayer(Player* player){
	auto panel = (GamePanel*)(getScene()->getChildByTag(panelTag));
	panel->setPlayer(player);
}
Rect Level::scaleRect(Rect& rect, float scale){
	float mul = scale;
	float mulN = 1 - mul;
	float minX = rect.getMinX()*mulN;
	float minY = rect.getMinY()*mulN;
	float maxX = rect.getMaxX()*mul;
	float maxY = rect.getMaxY()*mul;
	return Rect(minX, minY, maxX-minX, maxY-minY);
}

void Level::update(float dt){
	auto panel = (GamePanel*)(getScene()->getChildByTag(panelTag));
	auto player = panel->getPlayer();
	if (player){
		player->update();
		updateCameraOnPlayer(player);
	}
}
void Level::updateCameraOnPlayer(Player* player){
	auto sight = player->getEntitySight();
	auto camera = Follow::create(sight);
	map->getParent()->runAction(camera);
}